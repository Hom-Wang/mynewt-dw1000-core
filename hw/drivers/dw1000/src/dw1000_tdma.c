/**
 * Copyright (C) 2017-2018, Decawave Limited, All Rights Reserved
 * 
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 * 
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

#include <assert.h>
#include <string.h>
#include <stdio.h>
#include <math.h>
#include "sysinit/sysinit.h"
#include "os/os.h"
#include "bsp/bsp.h"
#include "hal/hal_gpio.h"
#include "hal/hal_bsp.h"
#ifdef ARCH_sim
#include "mcu/mcu_sim.h"
#endif

#include <dw1000/dw1000_dev.h>
#include <dw1000/dw1000_hal.h>

#if MYNEWT_VAL(DW1000_CCP_ENABLED)
#include <dw1000/dw1000_ccp.h>
#endif

#if MYNEWT_VAL(TDMA_ENABLED)
#include <dw1000/dw1000_tdma.h>

static void superframe_timer_cb(struct os_event * ev);
static void slot0_timer_cb(struct os_event * ev);

tdma_instance_t * tdma_init(struct _dw1000_dev_instance_t * inst, uint32_t period, uint16_t nslots){
    assert(inst);
    if (inst->tdma == NULL) {
        tdma_instance_t * tdma = (tdma_instance_t *) malloc(sizeof(struct _tdma_instance_t) + nslots * sizeof(struct os_callout *)); 
        assert(tdma);
        memset(tdma, 0, sizeof(tdma_instance_t) + nslots * sizeof(struct os_callout *));
        tdma->status.selfmalloc = 1;
        
        os_error_t err = os_mutex_init(&tdma->mutex);
        assert(err == OS_OK);
        tdma->nslots = nslots; 
        tdma->period = period; 
        tdma->parent = inst;
        inst->tdma = tdma;
    }
    os_callout_init(&inst->tdma->superframe_timer_cb, os_eventq_dflt_get(),  superframe_timer_cb, (void *) inst);
    tdma_assign_slot(inst->tdma, slot0_timer_cb, 0, (void *) inst);

    inst->status.initialized = true;

    return inst->tdma;
}


void 
tdma_free(tdma_instance_t * inst){
    assert(inst);  
    if (inst->status.selfmalloc)
        free(inst);
    else
        inst->status.initialized = 0;
}



void tdma_assign_slot(struct _tdma_instance_t * inst, void (* callout )(struct os_event *), uint16_t slot, void * arg){
    assert(slot < inst->nslots);
    if (inst->timer_cb[slot] == NULL){
        struct os_callout * timer_cb = (struct os_callout * ) malloc(sizeof(struct os_callout)); 
        assert(timer_cb);
        memset(timer_cb, 0, sizeof(struct os_callout));
        inst->timer_cb[slot] = timer_cb;
    }else{
        memset(inst->timer_cb[slot], 0, sizeof(struct os_callout));
    }
    os_callout_init(inst->timer_cb[slot], os_eventq_dflt_get(), callout, arg);
}

void tdma_release_slot(struct _tdma_instance_t * inst, uint16_t slot){
    assert(slot < inst->nslots);
    assert(inst->timer_cb[slot]);
    free(inst->timer_cb[slot]);
    inst->timer_cb[slot] =  NULL;
}


/*! 
 * @fn tmda_superframe_event_cb(struct os_event * ev)
 *
 * @brief This event is generated by ccp/clkcal complete event. This event defines the start of an superframe epoch. 
 * The event also schedules a tdma_superframe_timer_cb which turns on the receiver in advance of the next superframe epoch. 
 *
 * input parameters
 * @param inst - struct os_event *  
 *
 * output parameters
 *
 * returns none 
 */
void 
tdma_superframe_event_cb(struct os_event * ev){
    assert(ev != NULL);
    assert(ev->ev_arg != NULL);

    uint32_t utime = os_cputime_ticks_to_usecs(os_cputime_get32());
    printf("{\"utime\": %lu,\"msg\": \"superframe_event_cb\"}\n",utime);

    clkcal_instance_t * clkcal = (clkcal_instance_t *)ev->ev_arg;
    dw1000_ccp_instance_t * ccp = (void *)clkcal->ccp; 
    dw1000_dev_instance_t * inst = ccp->parent;
    tdma_instance_t * tdma = inst->tdma;

    os_callout_stop(&tdma->superframe_timer_cb);
    os_callout_reset(&tdma->superframe_timer_cb, OS_TICKS_PER_SEC * (tdma->period - MYNEWT_VAL(OS_LATENCY)) * 1e-6);
   
    for (uint16_t i=1; i < tdma->nslots; i++) {
        if (tdma->timer_cb[i]){
            os_callout_stop(tdma->timer_cb[i]);
            os_callout_reset(tdma->timer_cb[i], OS_TICKS_PER_SEC * (i * tdma->period/tdma->nslots - MYNEWT_VAL(OS_LATENCY)) * 1e-6);
        }
    }
    os_error_t err = os_mutex_pend(&tdma->mutex, OS_WAIT_FOREVER);
    tdma->idx = 0; 
    err |= os_mutex_release(&tdma->mutex);
    assert(err == OS_OK);   
}

/*! 
 * @fn superframe_timer_cb(struct os_event * ev)
 *
 * @brief This function is called prior to the next scheduled ccp event. The ccp event define the superframe or tdma slot0. 
 * This timer event provides loose coupling between the os and the tight dw1000 scheduling. This event should occur MYNEWT_VAL(OS_LATENCY) usec 
 * before the actual ccp event and perform an rx_start with a timeout set to a single tdma slot period.
 *
 * input parameters
 * @param inst - struct os_event *  
 *
 * output parameters
 *
 * returns none 
 */
static void 
superframe_timer_cb(struct os_event * ev){
    assert(ev != NULL);
    assert(ev->ev_arg != NULL);

    uint32_t utime = os_cputime_ticks_to_usecs(os_cputime_get32());
    printf("{\"utime\": %lu,\"msg\": \"superframe_timer_cb\"}\n",utime);
  
    dw1000_dev_instance_t * inst = (dw1000_dev_instance_t *)ev->ev_arg;
    tdma_instance_t * tdma = inst->tdma;

    dw1000_phy_forcetrxoff(inst);
    dw1000_set_rx_timeout(inst, 0);
    dw1000_start_rx(inst); 

    os_callout_reset(&tdma->superframe_timer_cb, OS_TICKS_PER_SEC * (tdma->period) * 1e-6);
   
    if (tdma->timer_cb[0]){
        os_callout_stop(tdma->timer_cb[0]);
        os_eventq_put(tdma->timer_cb[0]->c_evq, &tdma->timer_cb[0]->c_ev);
    }
    for (uint16_t i=1; i < tdma->nslots; i++) {
        if (tdma->timer_cb[i]){
            os_callout_stop(tdma->timer_cb[i]);
            os_callout_reset(tdma->timer_cb[i], OS_TICKS_PER_SEC * (i * tdma->period/tdma->nslots) * 1e-6);
        }
    }

    os_error_t err = os_mutex_pend(&tdma->mutex, OS_WAIT_FOREVER);
    tdma->idx++; 
    err |= os_mutex_release(&tdma->mutex);
    assert(err == OS_OK); 
 
}

/*! 
 * @fn slot0_timer_cb(struct os_event * ev)
 *
 * @brief slot0 is reserved for PAN master and Clock master frames. In this example this timer callback is 
 * used to start_rx.
 *
 * input parameters
 * @param inst - struct os_event *  
 *
 * output parameters
 *
 * returns none 
 */
static void 
slot0_timer_cb(struct os_event * ev){
    //uint32_t utime = os_cputime_ticks_to_usecs(os_cputime_get32());
    //printf("{\"utime\": %lu,\"msg\": \"slot0_timer_cb\"}\n",utime);
    dw1000_dev_instance_t * inst = (dw1000_dev_instance_t *)ev->ev_arg;

    dw1000_phy_forcetrxoff(inst); 
    dw1000_set_rx_timeout(inst, 0);
    dw1000_start_rx(inst);  
}

#endif //MYNEWT_VAL(TDMA_ENABLED)